/* autogenerated by Processing revision 1295 on 2025-02-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class SpaceInvaders extends PApplet {

Ship player;
int[] stars = new int[299];
int ROWS = 3;
int COLS = 7;
int ENEMYSIZE = 20;
int playerSize = 20;
PVector p;
PVector b;
PVector i;
int playerColor = color(100, 20, 200);
int bulletColor = color(200, 200, 0);
int BadbulletColor = color (204, 49, 106);
int level = 1;
Bullet bullet;
Bullet Badbullet;
EnemyGrid invaders;
boolean gameOver;
boolean won;
boolean paused;
int lives;
int score;


public void setup() {
  /* size commented out by preprocessor */;
  PVector p = new PVector(width/2, height-ENEMYSIZE/2);
  player = new Ship(p, playerSize, playerColor);
  invaders = new EnemyGrid(ROWS, COLS, ENEMYSIZE);
  PVector b = new PVector (-100, player.center.y - player.size);
  bullet = new Bullet(b, 5);
  PVector i = new PVector ((invaders.topLeft.x + ((random(COLS + 1))*ENEMYSIZE*1.5f)),
  invaders.topLeft.y + ((random(ROWS + 1))));
  Badbullet = new Bullet(i, 5);
  gameOver = false;
  won = false;
  paused = false;
  lives = 3;
  score = 0;
  makeStars();
}

public void draw() {
  if ((paused == false) && (gameOver == false) && (won == false)){
    background(51, 30, 105);
    
    for (int r = 0; r<stars.length-3; r+=3) {
      fill(240, 230, 255);
      circle(stars[r], stars[r+1], stars[r+2]);
      //println(stars[r], stars[r+1], stars[r+2]);
    }
    
    invaders.display();
    player.display();
    player.move();
    player.changeColor(playerColor);
    bullet.c = bulletColor;
    bullet.display();
    bullet.move();
    
    
    textAlign(RIGHT);
    textSize(20);
    text("lives: " + lives, 60, 15);
    textAlign(LEFT);
    textSize(20);
    text("score: " + score, width-72, 15);
    
    Badbullet.yspeed = 8;
    Badbullet.display();
    Badbullet.move();
    Badbullet.c = BadbulletColor;
    
    if (Badbullet.center.y >= height *3){
      int c = PApplet.parseInt(random(COLS));
      int r = PApplet.parseInt((random(ROWS)));
      if (invaders.grid[r][c] != null){
        Badbullet.center.x = invaders.topLeft.x + (c*ENEMYSIZE*1.5f);
        Badbullet.center.y = invaders.topLeft.y + r;
      }
    }
    
    Levels();
    
    boolean playerHit = Badbullet.collisionCheck(player);
    if (playerHit){
      lives = lives - 1;
      Badbullet.center.y = height +10;
    }
    
    boolean invaderHit = invaders.processCollisions(bullet);
    if (invaderHit) {
      //println("hit");
      if (level == 1){
        score += 100;
      }
      if (level == 2){
        score += 200;
      }
      newBullet();
    }
    //println(bullet.center.y);
    if (bullet.center.y < 0){
      newBullet();
    }
    if (frameCount % 30 == 0) {
      invaders.move();
    }
  }
  
  boolean completeDeath = invaders.hitPlayer(player);
    if (completeDeath) {
      gameOver = true;
    }
    if (lives == 0) {
      gameOver = true;
    }
    
    if((level == 2) && (invaders.allGone() == true)){
      won = true;
    }
    
  if (gameOver){
    background(51, 30, 105);
    textAlign(CENTER);
    textSize(width/10);
    text("GAME OVER", width/2, height/2);
    textSize(width/14);
    text("SCORE: " + score, width/2, height/2 + width/10);
  }
  
  if (won){
    background(51, 30, 105);
    textAlign(CENTER);
    textSize(width/10);
    text("YOU WON !!!", width/2, height/2);
    textSize(width/14);
    text("SCORE: " + score, width/2, height/2 + width/10);
  }
  
  if (paused){
    textAlign(CENTER);
    textSize(width/10);
    text("PAUSED", width/2, height/2);
  }
}


public void makeStars() {
  
  for (int r = 0; r<stars.length-3; r+=3) {
    stars[r] = (PApplet.parseInt(random(width)));
    stars[r+1] = (PApplet.parseInt(random(height)));
    stars[r+2] = PApplet.parseInt(random(2, 5));
  }
}

public void Levels() {
  boolean newLevel = invaders.allGone();
  if (newLevel && (level == 1)){
    print("newlebel");
    bullet.center.x = -100;
    delay(300);
    invaders.reset();
    invaders.level = 2;
    int level2Color = color(135, 200, 204);
    invaders.changeColor(level2Color);
    level = 2;
  }
}

public void keyPressed(){
  if (key == ' ') {
    bullet.center.x = player.center.x;
    bullet.yspeed = -15;
  }
  if (keyCode == LEFT) {
    player.center.x -= 3;
  }
  if (keyCode == RIGHT) {
    player.center.x += 3;
  }
  
  if (key == 'r') {
    gameOver = false;
    invaders.reset();
    lives = 3;
    player.center.x = width/2;
    player.center.y = height - playerSize/2;
    bullet.center.y = -100;
    Badbullet.center.y = height*2;
  }
}

public void mousePressed(){
  if ((mousePressed) & (mouseX < width) & (mouseY < height)){ 
    if ((paused == false) && (gameOver == false) && (won == false)){
      paused = true;
    }else{
      paused = false;
    }
  }
}

public void newBullet() {
  PVector b = new PVector (-100, player.center.y - player.size);
  bullet = new Bullet(b, 5);
}//newBullet
class Bullet {
  
  PVector center;
  int yspeed;
  int bsize;
  int c;
  
  Bullet(PVector p, int s) {
    bsize = s;
    center = new PVector(p.x, p.y);
  }
  
  public boolean collisionCheck(Enemy other) {
    return (this.center.dist(other.center) <= (this.bsize/2 + other.size/2));
  }//collisionCheck
  
  public boolean collisionCheck(Ship other) {
    return (this.center.dist(other.center) <= (this.bsize/2 + other.size/2));
  }//collisionCheck
  
  public void display() {
    strokeWeight(0);
    fill(c);
    ellipse(center.x, center.y, bsize, bsize*5);
  }//display
  
  public void move() {
    
    center.y += yspeed;
  }//move
  
}//Bullet
class Enemy {
  
  PVector center;
  int xspeed;
  int yspeed;
  int size;
  int c;
  
  Enemy(PVector p, int s, int col) {
    size = s;
    center = new PVector(p.x, p.y);
    c = col;
  }
  
  public void setColor(int newC) {
    c = newC;
  }
  
  public void display() {
    fill(c);
    circle(center.x, center.y, size);
  }//display
  
  public void setSpeed(int newx, int newy) {
    xspeed = newx;
    yspeed = newy;
  }//setSpeed
  
  public void move() {
    
    
    if (center.x > width - size/2 ||
        center.x < size/2) {
        xspeed*= -1;
     }
     if (center.y > height - size/2 ||
         center.y < size/2) {
         yspeed*= -1;
      }
     center.x+= xspeed;
     center.y+= yspeed;
  }//move
  
} //enemy

class EnemyGrid {
  Enemy[][] grid;
  int enemySize;
  PVector topLeft;
  int gridWidth;
  int gridHeight;
  int direction;
  int level;
  float yspacing;
  
  EnemyGrid(int rows, int cols, int eSize) {
    enemySize = eSize;
    grid = new Enemy[rows][cols];
    gridWidth = PApplet.parseInt(eSize * cols * 1.5f);
    gridHeight = PApplet.parseInt(eSize * rows * 1.2f);
    direction = RIGHT;
    topLeft = new PVector(enemySize/2, enemySize/2);
    makeEnemies();
    level = 1;
  }
  
  public void makeEnemies() {
    PVector pos = topLeft.copy();
    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[r].length; c++) {
        grid[r][c] = new Enemy(pos, enemySize, c);
        grid[r][c].setSpeed(enemySize, 0);
        pos.x += PApplet.parseInt(enemySize * 1.5f);
      }//columns
      pos.y += PApplet.parseInt(enemySize * 1.2f);
      pos.x = topLeft.x;
    }//rows
  }//makeEnemies
  
  public void display() {
    for (int r=0; r<grid.length; r++) {
      for (int c=0; c<grid[r].length; c++) {
        if (grid[r][c] != null) {
          grid[r][c].display();
        }
      }//columns
    }//rows
  }//drawGrid
  
  public boolean processCollisions (Bullet b) {
    boolean hit = false;
    for (int r = 0; r < grid.length; r++ ) {
      for (int c = 0; c < grid[r].length; c++) {
        if (grid[r][c] != null && b.collisionCheck(grid[r][c])) {
          grid[r][c] = null;
          hit = true;
          //println("hit");
        }//collision
      }//columns
    }//rows
    return hit;
  }//processCollisions
  
  public void move() {
    checkSpacing();
    
    if (direction == DOWN) {
      topLeft.y += enemySize;
    }
    else if (direction == LEFT) {
      topLeft.x -= enemySize;
    }
    else if (direction == RIGHT) {
      topLeft.x += enemySize;
    }
    
    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[r].length; c++) {
        if (grid[r][c] !=null) {
          grid[r][c].move();
        }
      }//columns
    }//rows

  }//move
  
  public void checkSpacing() {
    float leftEdge = topLeft.x - (enemySize/2);
    float rightEdge = leftEdge + gridWidth;
    float topEdge = topLeft.y - (enemySize/2);
    float bottomEdge = topEdge + gridHeight;
    
    if (level == 1){
      if (direction == DOWN) {
        if (leftEdge <= 0) {
          direction = RIGHT;
        }
        if (rightEdge >= width) {
          direction = LEFT;
        }
        changeDirection();
      }//switch left or right
      else if (leftEdge <= 0) {
        direction = DOWN;
        changeDirection();
      }
      else if (rightEdge >= width) {
        direction = DOWN;
        changeDirection();
      }
    }
    
    if (level == 2) {
      if (direction == DOWN) {
        if (leftEdge <= 0) {
          direction = DOWN;
          //print(topEdge);
          int danger = color(200, 100, 40);
          int peaceful = color(135, 200, 204);
          if ((topEdge >= width/5) && (topEdge <= (2*width/5)) && (bottomEdge < width - 30)){
          direction = RIGHT;
            changeColor(peaceful);
          }else{
            changeColor(danger);
          }
        }
        if (rightEdge >= width) {
          direction = LEFT;
        }
        changeDirection();
      }//switch left or right
      else if (leftEdge <= 0) {
        direction = DOWN;
        changeDirection();
      }
      else if (rightEdge >= width) {
        direction = DOWN;
        changeDirection();
      }
    }
    
  }//checkSpacing
  
  public void changeDirection() {
    int newx, newy;
    newx = 0;
    newy = 0;
    if (direction == LEFT) {
      newx = -enemySize;
    }//left
    if (direction == RIGHT) {
      newx = enemySize;
    }//right
    if (direction == DOWN) {
      newy = enemySize;
    }//down
    
    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[r].length; c++) {
        if (grid[r][c] != null) {
          grid[r][c].setSpeed(newx, newy);
        }
      }//columns
    }//rows
  }//changeDirection
  
 
  
  public boolean allGone() {
    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[r].length; c++) {
        if (grid[r][c] != null) {
          //println("more enemies");
          return (false);
        }
      }//columns
    }//rows
    println("no more enemies");
    return (true);
  }
  
  public void changeColor(int col){
    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[r].length; c++) {
        if (grid[r][c] != null){
          grid[r][c].setColor(col);
        }
      }
    }
  }
  
  public void reset() {
    topLeft.x = enemySize/2;
    topLeft.y = enemySize/2;
    makeEnemies();
    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid[r].length; c++) {
        grid[r][c].setSpeed(4, 1);
      }
    }
  }//
  
// END OF SECOND LEVEL STUFF
  
  public float findBottom(){
    float topEdge = topLeft.y - (enemySize/2);
    for (int r = grid.length-1; r > 0; r--) {
      for (int c = grid[r].length -1; c > 0; c--) {
        if (grid[r][c] != null) {
          return (grid[r][c].center.y);
        }
      }
    }
    return (topEdge);
  }
  public boolean hitPlayer(Ship other) {
    float bottomEdge = findBottom();
    //println(bottomEdge, bottomEdge - enemySize,  height - other.size);
    return (( bottomEdge)
             >= (height - other.size) );
  }
  
}//EnemyGrid
class Ship {
  
  //instance variables
  PVector center;
  int xspeed;
  int size;
  int c;
  
  //default constructor
  Ship(PVector p, int s, int col) {
    size = s;
    center = new PVector(p.x, p.y);
    c=col;
  }
  
  public void changeColor(int newC){
    c = newC;
  }// change color
  
  public void display() {
    fill(c);
    circle(center.x, center.y, size);
  }//display
  
  public void setSpeed(int newx, int newy) {
    xspeed = newx;
  }//setSpeed
  
  public void move() {
    if ((center.x < width - size/2) & (center.x > size/2)){
      center.x += xspeed;
    }
  }//move

}//ship


  public void settings() { size(300, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "SpaceInvaders" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
